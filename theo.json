[
    {
        "instruction" : "A Non-Deterministic Finite State Machine is a 5 Tuple: Define it",
        "response" : "1. Q is a finite set of states 2. Σ is a finite set called the alpahbet 3. δ : Q x Σ > P(Q) is the transition function 4. q0 ∈ Q is the start state 5. F ⊆ Q is the set of accept states "
    },

    {
        "instruction" : "A Deterministic Finite State Machine is a 5 Tuple: Define it",
        "response" : "1. Q is a finite set of states 2. Σ os a finite set called the alphabet 3. δ : Q x Σ > Q is the transistion state 4. q0 ∈ is the start function 5. F ⊆ Q is the set of accept states "
    },

    {
        "instruction" : "A Context Free Grammar is a 4 tuple: Define it.",
        "response" : "1. V is a finite set called the variables 2. Σ is a finite set distjoing from V ccalled terminals 3. R is a finite set of rules, with each rule being a variable and a string of variables adn terminals 4. S ∈ V is the start variable "
    },
    
    {
        "instruction": "A Pushdown Automata (PDA) is a 6 Tuple: Define it.",
        "response" : "1.  Q is the set of states 2. Σ is the input alphabet 3. Γ is the stack alphabet 4. δ : Q x Σε x Γε -> P(Q x Σε x Γε) is the transition function 5. q0 ∈ Q is the start state 6. F ⊆ is the set of accept states"
    },

    {
        "instruction" : "A Turing Machine is a 6 Tuple: Define it.",
        "response" : "1. Q is a the set of states 2. Σ is the input alphabet not containing the blank symbol 3. Γ is the tape alphabet, where Σ ⊆ Γ and the blank symbol ∈ Γ 4. δ : Q x Γ -> Q x Γ x {L, R} is the transition function 5. q0 ∈ Q is the start state 6. F ⊆ Q is the set of accept states"
    },

    {
        "instruction" : "What are Regular Languages Closed Under?",
        "response" : "1. Union 2. Kleene Star 3. Concatenation 4. Intersection 5. Complementation"
    },

    {
        "instruction" : "What are Decidable Turing Machines Closed Under?", 
        "response" : "1. Union 2. Kleene Star 3. Concatenation 4. Intersection 5. Complement"
    },

    {
        "instruction" : "What are Recognizing Turing Machines Closed under?",
        "response" : " 1. Union 2. Kleene Star 3. Concatentation 4. Intersection"
    },

    {
        "instruction" : "What are the 6 conditions for a Regular Expression??",
        "response" : "1. a for some a in the alphabet Σ 2. ε (the empty string) 3. empty language ∅ 4. (R1 ⋃ R2) where R1 and R2 are regular expressions 5. (R1 ° R2) where R1 and R2 are regular expressions 6. (R1*) where R1 is a regular expression"
    },

    {
        "instruction" : "What is Class P Closed Under",
        "response" : "1. Union 2. Kleene Star 3. Concatenation 4. Intersection 5. Complement"
    },

    {
        "instruction" : "Describe CFL closure under union",
        "response" : " Let L1 and L2 be context free languages Formally Defined, G(L1) = (V1, E, R1, S1} and G(L2) = {V2, E, R2, S2}. To build a union grammar S --> S1 | S2 Formally Defined: G = (V1 ⋃ V2 ⋃ {S}, E, R1 ⋃ R2 ⋃ {S --> S1 | S2}, S) and V1 ∩ V2 = ∅ (are disjoint)"
    },

    {
        "instruction" : "Describe CFL closure under Concatenation",
        "response" : " Let L1 and L2 be context free languages Formally Defined, G(L1) = (V1, E, R1, S1} and G(L2) = {V2, E, R2, S2}. To build a concatenation grammar S --> S1 ° S2 Formally Defined: G = (V1 ⋃ V2 ⋃ {S}, E, R1 ⋃ R2 ⋃ {S --> S1 ° S2}, S) and V1 ∩ V2 = ∅ (are disjoint)"
    },

    {
        "instruction" : "Describe CFL clousre under Star",
        "response" : " Let L1 be a context free language Formally Defined, G(L1) = (V1, E, R1, S1}. To build a star grammar S --> S1 ° S | ε Formally Defined: G = (V1 ⋃ {S}, E, R1 ⋃ {S --> S1 ° S | ε}, S) "
    },

    {
        "instruction" : "Describe Deciding TM closure under Union",
        "response" : "Let L1 and L2 be decidable and TM m1 and M2 decide the respectively. Build M to decide L1 U L2: M = 'On input W 1. Copy w to tape 2 2. Simulate M1 on w using tape 1 if M1 accepts , the accept. 3. Simulate M2 on w using tape 2 if M2 accepts then accept, if M2 rejects, then reject.'"
    },

    {
        "instruction" : "Describe Deciding TM closure under Concatenation",
        "response" : "Let L1 and L2 be decidable and TM m1 and M2 decide respectively. Build M to decide L1 ∘ L2 M = 'On input w 1. For every possible split of w int w1w2 2. Copy w1 to tape 2. rune M1 on tape 1 Copy w2 to tape 2. Run M2 on tape 2 3. If both accept, then accept. 4. If all ways tried without success, reject.'"
    },

    {
        "instruction" : "Describe Deciding TM closure under Star",
        "response" : "Let L be decidable and TM M decides it. Build M to decide L*. M = 'On input w: 1. Split w into n parts such that w = w1w2...wn in different ways. 2. Run M on Wi for i = 1,2... n 3. If < accepts each of these string Wi then accept 4. If all attempts fail then reject.'"
    },

    {
        "instruction" : "Describe Deciding TM closure under Complementation.", 
        "response" : "Let L be a decidable language and M be a TM that decides it Build TM M' to decide L'. M' = 'On input w: 1. Run M on w 2. If M accpets, then reject 3. If M rejects, then accept.'"
    },
    
    {
        "instruction" : "Describe NDTM closure under Union", 
        "response" : "Let L1 and L2 be recognizable and TM M1 and M2 recognize. Build TM M to recoginze L1 ⋃ L2: M = 'On inpout w 1. Copy w to tape 2. Run M1 on w using tape 1 and M2 on w using Tape 2 (Run in parallel) 3. If M1 or M2 accepts, then accept. 4. If both reject, then reject.'"
    },

    {
        "instruction" : "Describe NDTM closure under Star",
        "response" : "Let L be a T-recog language and M be the TM that recognizes. Build TM to recognize L*. M = 'On input w 1. Non-deterministically split w int w1, w2 ... wn 2. run M on each wi 3. If all wi are accepted, then accept. 4 if any wi is rejected, then reject.'"
    },

    {
        "instruction" : "Describe NDTM closure under intersection",
        "response" : "Let L1 and L2 be recoginzable and TM M1 and M2 recognize. Build TM M to recognize L1 ∩ L2: M = 'On input w 1. Copy w to tape 2. Run M1 on w using tape 1 2. If M1 rejects, then reject 3. Run M2 on w using tape 2 4. If M2 accepts, then accpet 5. if M1 or M2 rejects then reject.'"
    },

    {
        "instruction" : "Describe NDTM closure under Concatenation", 
        "response" : "Let L1 and L2 be recognizable and TM M! and M2 recoginize. Build TM M to recognize L1 ∘ L2: M = 'On Inut w 1. non deterministically divide w int w1w2 2. Run M1 on w1 using tape 1, if M1 rejects, the reject 3. Run M2 on w2 using tape 2, If M2 accpets, then accpet. 4. If M2 rejects, then reject.'"
    },

    {
        "instruction" : "How do you show something is a regular language?",
        "response" : "1. Give a regular expression for it. 2. Give a DFA that recognizes it. 3. Use closure properties"
    },

    {
        "instruction" : "How do you show something is context free?",
        "response" : "1. Give a CFG for it 2. Make a PDA."
    },
    
    {
        "instruction" : "How do you show something is decidable?",
        "response" : "1. Give a TM that decides it 2. Use closure properties 3. Give an algorithim for it."
    },

    {
        "instruction" : "State the Churh-Turing Thesis",
        "response" : "Any turing maching that halts on all inputs can be considered an algorithim, and any algorithim can be rendered as a turing machine that halts on all inputs"
    },

    {
        "instruction" : "State Cook-Levin Theorem",
        "response" : "The Boolean satisfiability problem (SAT) is NP-complete. That is, any problem in NP can be reduced in polynomial time by a deterministic Turing Machine to the problem of dettermining whether a Boolean formula is satisfiable."
    },

    {
        "instruction" : "Describe the CONNECTEDNESS algorith and state its class",
        "response" : "A= {<G> | G is an undirected connected graph} TM(algo) to decide A: M='On input <G> where G is an undirected graph 1. Mark first node 2. Repeat until no new nodes are marked 3. Mark any unmarked node connected by edge to marked node. 4. Scan nodes to see if all are makred. If so, accept, else reject.' class: P"
    },

    {
        "instruction" : "Descibe the PATH algorithim and state its class",
        "response": "Algorithim to determine if there is a path between 2 nodes. M ='On input <G, s, t> where G is a directed graph with a bath between nodes s and t: 1. Place mark on node S 2. Repeat until no new nodes are marked: 3. Scan edges of G. if edge (a,b) found going from makred node a to unmarked node b 4. If t is makred accept, else reject.' Time Complexity: P"
    },

    {
        "instruction" : "Describe the EULER algorithim and state its class",
        "response" : "Euler = {<G, s, t> | G is a graph with an Eulerian path (traverse each edge exactly once) from s to t} Build TM M to decide Euler: M = on input <G, s, t> where G is a graph 1. Compute the degrees of all nodes in G. 2. If s = t AND all the nodes are even degree accept; else  rejct. 3. If s ≠ t AND s and t are odd degree and all other nodes are even degree accept; else reject. Time Complexity: P"
    },

    {
        "instruction" : "Descibe the HAMILTON algorithim and state its class",
        "response" : "HAMPATH = {<G, s, t> | G is a graph that has a path from s to t and goes through every node exactly once} there is no known polytime solution. however Hampath can be verified in polynomial time. Class: NP"
    },

    {
        "instruction" : "Describe the Travelin G SP algorithim and state its class",
        "response" : "Description: Given a set of cities and the distance between every pair of cities. The problem is to find the shortesst possible rout that visits every city EXACTLY ONCE and returns to the starting point. 1. Consider city 1 as starting point (arbitrary). 2. Generate all (n-1)! permutation and keep track of the minimum permutation cost. Return the permutation with minimum cost. Time Complexity: O(n!) Class: NP"
    },

    {
        "instruction" : "Describe the CLIQUE algorithim and state its class",
        "response" : "A subgraph in a undirected graph that is a complete graph. A CLIQUE of size K contains K nodes. CLIQUE = {<G, k> | G is an undirected graph with a k-clique} No known polytime solution however can be verified in polynomial time. Class: NP"
    },

    {
        "instruction" : "Describe the INDEPENDENT SET algorithim and state its class",
        "response" : "A subgraph in an undirected graph where no 2 nodes are connected by an edge. IS = {<G, k> | G is an undirected graph with a k-sized independent set} No known polytime solution however can be verified in polynomial time. Class: NP"
    },

    {
        "instruction" : "Describe the SUBSET SUM algorithim and state its class",
        "response" : "A subset of a given mutliset of integers that adds up to the target, t. SUBSET SUM = {<S, t> | S = {x1, x2, ... xn} and for some {y1, y2, ... yk} ⊆ S, we have ∑ yi = t} No known polytime solution however can be verified in polynomial time. Class: NP"
    },

    {
        "instruction" : "Describe the PARTITION algorithim and state its class",
        "response" : "PAR = {<S> | S = {x1, x2, ... xk} and π(a partition of S) exists such that ∑ (xᵢ ∈ π) xᵢ = ∑ (xᵢ ∉ π) xᵢ } Class: NP"
    },

    {
        "instruction" : "Describe the 2MACHINE SCHEDULING algorithim and state its class",
        "response" : "2MS  = {<S, D> | S = {x1, ... xk}, a set of process times and D a deadline and there is a way to schedule the k process on 2 machines withing the deadline} Class: NP"
    },

    {
        "instruction" : "Describe the VERTEX COVER algorithim and state its class",
        "response" : "A vertex civer if G us a subset of the nodes where every edge of G touches one of those nodes. VC = {<G, k> | G is an undirected graph with a k-node vertex cover} Class: NP"
    },

    {
        "instruction" : "Describe the SAT algortihm and state its class",
        "response" : "A Boolean formula that has a variable combination that evaluates as true SAT = {<φ> | φ is a satisfiable Boolean formula} Class: NP"
    },

    {
        "instruction" : "Describe the 3SAT algorithim and state its class",
        "response" : "3SAT = {<φ> | φ is a satisfiable 3NCF (Boolean formula in CNF with each clause having exactly 3 literals)} Class: NP"
    },

    {
        "instruction": "Acceptance problem for DFAs",
        "response" : "A_DFA = {<B, w> | B is a DFA that accepts input string w} Solution: M = 'On input <B, w> 1. Simulate B on input w 2. If B ends on Final state, accept. Else reject.' Class: P"
    },

    {
        "instruction" : "Acceptance problem for NFAs",
        "response" : "A_NFA = {<B, w> | B is a NFA that accepts input string w} Solution: M = 'On input <B, w> 1. Simulate B on input w 2. If B ends on Final state, accept. Else reject.' Class: P or Convert NFA to DFA 2. Run Acceptance problem for DFA"
    },

    {
        "instruction" : "Acceptance Problem for REX",
        "response" : "A-rex = {<R, w> | R is a REX that accepts input string W} Solution : M = 'On input <R, w> 1. Convert R to a NDF, N 2. Convert N to a DFA D, 3. Simulate D on input W. 4. If D ends in a final state accept ELSE reject.' Class: P"
    },

    {
        "instruction" : "What makles a language T-Recognizable?",
        "response" : "IFF some NDTM recognizes it"
    },

    {
        "instruction" : "What makes a language T-Decidable?",
        "response" : "IFF some DTM decides it"
    },

    {
        "instruction" : "Emptiness Testing for Regular Expression",
        "response" : "Given a DFA, Does this DFA accept NO STRINGS? Edfa = {<A> | A is a DFA and L(A) = ∅} M = 'On input <A> A is a DFA. 1. Mark start state 2. Repat until no new nodfes makred 3. Mark any unmarked node with transition into it from a marked node. 4. If no final states are marked accept; else reject.'"
    },

    {
        "instruction" : "Equivalence Testing for Regular Expressions",
        "response" : "EQ_DFA = {<A, B> | A and B are DFAs and L(A) = L(B)} M = on input <A, B> where 1. Minimize A to get A' 2. Minimize B to get B' 3. Check if A' is isomorphic to B' if so Accept, else reject."
    },

    {
        "instruction" : "Acceptance Problem for CFGs",
        "response" : "A_cfg = {<G,w> | G is a CFG that generates string w} 1. Convert G to CHOMSKY NORMAL FORM. 2. If w = ε and So --> ε is a rule in G, accept. 3. Let n be the length of w. Generate all derivations of G with exactly 2n-1 steps. If any of these derivations generate w, accept; else reject."
    },

    {
        "instruction" : "Accaptance problem for PDA",
        "response" : "Convert A_pda to CFG then A_pda = A_cfg {<G, w> | G is a CFG that generates string w} 1. Convert G to CHOMSKY NORMAL FORM. 2. If w = ε and So --> ε is a rule in G, accept. 3. Let n be the length of w. Generate all derivations of G with exactly 2n-1 steps. If any of these derivations generate w, accept; else reject."
    },

    {
        "instruction" : "Emptiness Testing for CFG",
        "response" : "E_cfg = {<G> | G is a CFG and L(G) = ∅} M = 'On input <G> where G is a CFG 1. Mark all terminal symbols in G 2. Repeat until no new variables are marked: Mark any variable A where there is a rule A --> U1U2... Uk such that each Ui is marked 3. If the start variable S is not marked, accept; else reject.'"
    },

    {
        "instruction" : "Equivalence Testing CFG",
        "response" : "EQ_cfg = {<G, H> | G and H are CFG and L(G) = L(H)} NOT DECIDABLE"
    },

    {
        "instruction" : "Prove that Every CFG is Decidable",
        "response" : "Build TM M to decide CFL A build a copy of grammar G into Mg. Mg = 'on input 1. Convert G to chomsky Normal Form 2. If w = ε and So --> ε is a rule in G, accept, else reject. 3. Let n be the length of w. Generate all derivations of G with exactly 2n-1 steps. If any of these derivations generate w, accept; else reject.'"
    },

    {
        "instruction" : "Prove Accepatnce for TM (Turing Recongizable)",
        "response" : "Atm = {<M, w> |M M is a TM and M accepts W} Here is a TM U to recognize it wher U = universal TM. U = {<M, w> | is a TM and W a string} 1. Simulate TM on input w 2. If M does enter Qaccept, then accept. 3. If M does not enter Qaccept, OR enters Qreject, Reject"
    },

    {
        "instruction" : "Prove A(TM) is not Decidable",
        "response" : "Assume Atm is decidable, then obtrain a contradiction. Let H be decideer for ATM, that is on input <M,w> where M i a TM and W is a string. H(<M,w>) = {1. accept if M accepts w 2. reject if M does not accept w) Now, consider a TM D with H as a sub-routine D = 'On input <M>, where M is a TM 1. Run H on input <M, <M>> 2. Output the opposite of what H outputs, if H accepts, reject and if H rejects then accept. Now run D using <D> as input D(<D>) = (1. accept if D does not accept <D> 2. Reject, if D accept <D>) there fore contraddiction. Hence Atm is not decidable."
    },

    {
        "instruction" : "Describe the Halting Problem",
        "response" : "Halt TM is undecidable. Assume HaltTm is decidebale and R is a TM that decides. Build TM to decide ATM S = 'on input <M,w> 1. Run R on <M,w> 2. if R rejects, rejeect, 3. If R accepts, proceed to next phase. Simulate M on input w: If M acepts, Accept, If M rejects, reject.' Hence HaltTM is undecidable."
    },

    {
        "instruction" : "Define TIme Complexity (3 PART)",
        "response" : "1. Let M be a determinisitc TM that halts on all inputs. 2. Time complexity, of M is a function f: N -> N. 3. where f(n) is the maximum number of steps that M uses on any input of length n."
    },

    {
        "instruction" : "Estimate Time COmplexity of A = {a^k b^k}",
        "response" : "M = 'On input <w>: 1. Scan the tape and reject if an 'a' is found to the right of a 'b'. 2. Repeat while both a's and b's remain on the tape. 3. Scan the tape crossing off exactly one and and exactly one b. 4. Scan tape: if either a or b symbols remain, reject else accept.' 1. O(n) 2. O(n/2) 3. O(n) total time complexity is O(n^2) Class: P"
    },

    {
        "instruction" : "Estimate Time COmplexity of A = {a^k b^k} using Two Tapes",
        "response" : "M = 'On input <w> 1. Scan tape across tape 1; reject if an 'a' is found to the right of a 'b'. 2. can a's on tape 1 until the first b. at the same time, copy the a's onto tape 2. 3. Scan b's on tape1 until end of tape. For each b found on tape 1, cross off an a on tape 2. 4. ACCEPT IF: all a's on tape 2 are crossed off and no b's remain on tape 1; else REJECT.' Time Complexity: O(n) Class: P"
    },
    
    {
        "instruction" : "Describe ALgorithim for Convertig Multitape to Single Tape and describe time complexity",
        "response" : "1. Put standard tape(single tape) in proper form. 2.a) to simulate a single move scan tape to determine the symbols under the virtual aheads b) scan again to update tape's/perform actions according to M's transition function 3. If at any time, an action would move virtual head unto #, instead shift right from here to end of tape, insert #*' Time Complexity: 1. O(n) 2. Single move(t(N)) conclusion every t(n) time multitape has O(t^2(n)) single tape simulation."
    },
    
    {
        "instruction" : "What is the running time of a NDTM?",
        "response" : "The running time is the function f: N -> N, where f(n) is the max number of steps that N uses on any pranch of its computation on an input length n."
    },

    {
        "instruction": "Describe Algorithim for Converting NDTM to DTM and describe the algorthim's time complexity",
        "response" : "1. Initially tape 1 has input w, tape 2 and 3 are empty. 2. COpy w to tape 2. 3. Use tape 2 to simulate NDTM's operation before each step, consult tape 3 to see which choice to make, if no more symbols on tape 3 (illegal/invalid choice) (Encounter Qreject, proceed to next step) 4. replace string on tape 3 with next value in string order 5. Go back to step 2."
    },

    {
        "instruction": "What is the Time Complexity of Regular Expression to NFA conversion?",
        "response" : "POLYNOMIAL"
    },

    {
        "instruction": "What is the Time Complexity of NFA to DFA conversion?",
        "response" : "EXPONENTIAL"
    },

    {
        "instruction": "What is the Time Complexity of DFA minimization?",
        "response" : "POLYNOMIAL"
    },

    {
        "instruction": "What is the TIme Complexity to describe DFA ISOMORPHISM",
        "response" : "POLYNOMIAL"
    },

    {
        "instruction" : "what is the Time complexity FOR ACCPETNACE DFA",
        "response" : "POLYNOMIAL"
    },

    {
        "instruction" : "What is teh TIme Complexity for DFA to REGEX conversion",
        "response" : "EXPONENTIAL"
    },

    {
        "instruction" : "WHat is Dynamic Programming?",
        "response" : "Is a method in whihc a problem is broken into smaller subproblems whose solutions are stored and results are used to solve the larger problems."
    },

    {
        "instruction" : "What makes a language in NP?",
        "response" : "A language is in NP IFF it is decided by some nondeterministic polynomial time turing machine. (NDTM)"
    },

    {
        "instruction" : "Describe NP algorithm for Subset sum",
        "response" : "V = <on input <S, t> 1. test whether c is a collection of numbers that sum up to t. 2. Terst whether s contains all the nubmers in c. 3. If both pass, accept,; otherwise reject.'"
    },

    {
        "instruction" : "Describe NP/NDTM algorithm for Hamiltonian Path",
        "response" : "N1 = 'On input <G, s, t> where G is a directed graph with nodes s and t. 1. Write a list of m numbers p1...pm where m is the number of nodes in G. Each nubmer in the list is Nondeterministically selected between 1 and m. 2. check for repetitions in teh list. If any are found, reject. 3. Check whether s = P1 and t = Pm. IF either fial, reject 4. For each 1 between 1 and m-1, check whether (pi, pi+1) is an edge of graph G. If any are not, reject. Otherwise all tests have been passed so accpet.'"
    },

    {
        "instruction" : "Describe NP algorithim for CLIQUE",
        "response" : "{<G,k> | G is an undirected graph with a k-clique} 1. (Build a verifier V for clique V = 'On input <G, k, c> 1. test whtther c is a subgraph with k nodes in G. 2. Test whehter G contains all edges connecting nodes in C 3. If both pass, acceptl else reject.) 2. (Build a poly time NDTM N = 'On input <G, k> where G is a grpah. 1. Nondeterminisitically select a subset c of k nodes of G 2. Test whether G contains all edges connecting nodes in C. 3. If yes, accpet; otherwishe reject.')"
    },

    {
        "instruction" : "Describe algorithim for NFA to DFA",
        "response" : "1. Start with the start state of the DFA being the epsilon closure of the start state of the NFA. 2. For each symbol in the alphabet, compute the transition from each DFA state by taking the union of the transitions from each NFA state in the DFA state, followed by taking the epsilon closure of that set. 3. Repeat step 2 until no new DFA states are generated. 4. Mark any DFA state that contains an accept state of the NFA as an accept state of the DFA."
    },

    {
        "instruction" : "Describe algorithm for RE to NFA",
        "response" : "1. For each symbol in the regular expression, create a basic NFA that recognizes that symbol. 2. For union operations, create a new start state with epsilon transitions to the start states of the NFAs for each operand. 3. For concatenation operations, connect the accept state of the first NFA to the start state of the second NFA with an epsilon transition. 4. For Kleene star operations, create a new start state and a new accept state. Add epsilon transitions from the new start state to the old start state and from the old accept state back to the old start state, as well as an epsilon transition from the new start state to the new accept state."
    },

    {
        "instruction" :  "Describe algorithim for DFA to RE",
        "response" : "1. Create a generalized transition graph (GTG) from the DFA, where each edge is labeled with a regular expression representing the transitions between states. 2. For each pair of states (i, j), update the GTG by replacing the direct transition from i to j with a new regular expression that accounts for all possible paths from i to j, including loops and intermediate states. 3. Repeat step 2 until there is only one state left in the GTG, which will be the start state. 4. The regular expression labeling the transition from the start state to the accept state(s) in the final GTG is the equivalent regular expression for the original DFA."
    },

    {
        "instruction" : "Describe algorithim for state minimization of",
        "response" : "1. Remove unreachable states by performing a reachability analysis from the start state. 2. Partition the states into two groups: accept states and non-accept states. 3. Refine the partitions by checking transitions for each input symbol, splitting groups as necessary until no further refinement is possible. 4. Create a new DFA where each group of equivalent states is represented by a single state, and define transitions based on the original DFA's transitions."
    },

    {
        "instruction" : "Describe big loop algorithim CFG to PDA",
        "response" : "1. For each production rule A --> α in the CFG, create a transition in the PDA that pops A from the stack and pushes the symbols of α onto the stack in reverse order. 2. Add a transition that reads an input symbol a and pops a from the stack when the top of the stack matches the input symbol. 3. Initialize the PDA with the start symbol of the CFG on the stack and an empty input tape. 4. The PDA accepts by empty stack when all input symbols have been read and the stack is empty."
    },

    {
        "instruction" : "Describe CFG to DFA",
        "response" : "1. Convert the CFG to Chomsky Normal Form (CNF) to simplify the structure of the productions. 2. Construct a pushdown automaton (PDA) that simulates the derivations of the CFG by using the stack to keep track of non-terminals and input symbols. 3. Since DFAs cannot handle context-free languages directly, use the PDA to recognize the language and then apply the subset construction method to convert the PDA into an equivalent NFA. 4. Finally, convert the NFA into a DFA using the standard NFA to DFA conversion algorithm."
    },

    {
        "instruction" : "Describe PDA to CFG",
        "response" : "1. For each transition in the PDA that reads an input symbol and pops a stack symbol, create a production rule in the CFG that generates the input symbol and replaces the stack symbol with the corresponding non-terminal. 2. For transitions that push symbols onto the stack, create production rules that generate the corresponding non-terminals for those symbols. 3. Define the start variable of the CFG to correspond to the initial configuration of the PDA, including the start state and the initial stack symbol. 4. Ensure that the CFG generates all strings accepted by the PDA by including rules that account for all possible transitions and stack operations."
    },

    {
        "instruction" : "Describe algorithm for RE to CFG",
        "response" : "1. For each basic symbol a in the regular expression, create a production rule S --> a. 2. For union operations R1 ⋃ R2, create a new start variable S and add production rules S --> S1 | S2, where S1 and S2 are the start variables for the CFGs corresponding to R1 and R2, respectively. 3. For concatenation operations R1 ° R2, create production rules S --> S1 S2, where S1 and S2 are the start variables for the CFGs corresponding to R1 and R2, respectively. 4. For Kleene star operations R*, create a new start variable S and add production rules S --> S1 S | ε, where S1 is the start variable for the CFG corresponding to R."
    },

    {
        "instruction" : "Describe CHomsky Algortihm for CFG to CNF",
        "response" : "1. Eliminate null productions by removing any production A --> ε and adjusting other productions accordingly. 2. Eliminate unit productions by replacing any production A --> B with the productions of B. 3. Remove useless symbols by eliminating non-terminals that do not derive any terminal strings or cannot be reached from the start symbol. 4. Convert remaining productions into CNF by ensuring that all productions are of the form A --> BC or A --> a, where A, B, and C are non-terminals and a is a terminal symbol."
    },
    
    {
        "instruction" : "Describe the Pumping Lemma",
        "response" : "For any regular language L, there exists a pumping length p such that any string s in L with length at least p can be divided into three parts, s = xyz, satisfying the following conditions: 1. The length of xy is at most p (|xy| ≤ p). 2. The length of y is at least 1 (|y| > 0). 3. For all integers i ≥ 0, the string xy^i z is also in L."
    },

    {
        "instruction" : "Prove CLF not closed under Complement/intersection",
        "response" : "A N B = double complement of (A n B) = All comp (Acomp U B comp). This would be valid if we were closed under complement but we are not. "
    },

    {
        "instruction" : "Prove that the intersection a CFL and a Regular Language is CF",
        "response" : "L = C ⋂ R where L and C are Context free and R is a regulare language. Let P be the PDA for C and D be the DFA for R, let Q be set of states for P and Q' be the set of States for D. Construct PDA P' that will do everything P will do and also  keep track of D, Q x Q'. P' will accept string w iff it stops at an accept state q, belonging to FPxFD where FP and FD are the final states for P and D respectively. Since C ⋂ R is recongized by P' the cfl intersction is proved."
    },

    {
        "instruction": "Describe wyas to find the left-hand edge of the tape",
        "response" : "1. Shift Right until blank symbol is found. 2. Mark and attempt left shift. 3. Secpail symbols: a) augmented symbol repleaces 1st position b) remembered with tape."
    },

    {
        "instruction" : "What is the General Reduction Proof?",
        "response" : "If A polytime reducibe to B, and B is a member of Polytime, then A is a memeber of Polytime decidable languages."
    },

    {
        "instruction" : "Describe the General Reduction Proof algorithim",
        "response" : "Let M be the polytime algorithm deciding B and f be the polytime reductrion from A to B. Here is a poly time alogrithim N to decide A: N ='On input <w> 1. Compute f(w) 2. Run M on input f(w) and output whatever M outputs.' N runs in polytime because steps 1 and 2 both run in poly time, and the output of stage 1 can oly be polylength in size of the original input."
    },

    {
        "instruction" : "Describe 3-SAT reducible to VERTEX COVER",
        "response" : "1. For each literals draw nodes for true and flase and draw edge between them. 2. For each cluase draw a triangle of nodes and draw edges between them. m = # of variables and l = # of clauses. # nodes = 2m + 3l and size of vertex cover(k) = m + 2l. In a vertex cover, every edge gets covered (picked). Within nodes pick what makes it true within each clasuse pick 3 that dont mike it true. Conclusion : If we do end up with a VC then we have a true soluton for 3SAT."
    },

    {
        "instruction" : "Descirbe Partition Subset",
        "response" : "1. Partition will give you a list of numbers. 2. Divide the sume of those numbers byt 2 to opatin H. 3. Send all multiset partionin values to subset sum with H as the target T. 4. If H is an integer check if values in subset-sum meet the target. If Yes, then we are polty time reducible and the problem is solved 5. If H is not an integer. the send an integer value of H that is gaurenteed to fail as a target. So if partiion is solvable, then subset-sum is also solvable."
    },

    {
        "instruction" : "Describe Subset-Sum to Partition",
        "response" : "Subset sum starts with multiset of integers with t as target. Miracle Option: If H = T then we are done. Normal Option: 1. Compute S = sum of all integers in the multiset. 2. Create a new multiset S' by adding 1 integer x = S - 2T to the original multiset. 3. Send S' to partition problem. Conclusion: If subset-sum is solvable, then partition is also solvable."
    },

    {
        "instruction": "Describe Partion to 2-Machine Scheduling",
        "response" : "1. Partition will give you a list of numbers. 2. Compute S = sum of all integers in the multiset. 3. Send all integers to 2-machine scheduling with D = S/2 as the deadline. Conclusion: If partition is solvable, then 2-machine scheduling is also solvable."
    },

    {
        "instruction" : "Describe 2-Machine Scheduling to Partition",
        "response" : "2-machine scheduling starts with a set of process times and a deadline D. Miracle Option: If S = 2D then we are done. Normal Option: 1. Compute S = sum of all process times. 2. Create a new set of process times S' by adding 1 process time x = 2D - S to the original set. 3. Send S' to partition problem. Conclusion: If 2-machine scheduling is solvable, then partition is also solvable."
    },

    {
        "instruction" : "Describe SUbset Sum to 2MS",
        "response" : "Subest Sum ≤p PAR ≤p 2MS"
    },

    {
        "instruction" : "Describe 2ms to SUBSET SUM",
        "response" : "2MS ≤ p PAR ≤ p SUBSET SUM"
    }, 

    {
        "instruction" : "Describe Hamiltonian to TSP",
        "response" : "1. Hamiltonian path gives you a graph G with nodes s and t. 2. Create a complete graph G' from G where edges in G have weight 1 and edges not in G have weight 2. 3. Send G' to TSP with k = number of nodes in G. Conclusion: If Hamiltonian path is solvable, then TSP is also solvable."
    },

    {
        "instruction" : "What is ploynomial time computable function?",
        "response" : "A function f: Σ* -> Σ* is polynomial time computable if some DTM M exists that on every input w halts with f(w) on its tape after O(|w|^k) steps for some constant k."
    },
     
    {
        "instruction" : "What is polynomial time reducible function?",
        "response" : "A language A is polynomial time reducible to language B, written A ≤p B, if a polynomial time computable function f: Σ* -> Σ* exists such that for every w ∈ Σ*, w ∈ A iff f(w) ∈ B."
    },

    {
        "instruction" : "Enumerators",
        "response" : "RL: Recognizes(DFA, NFA, FSMs) Generates(RegEx), CF: Recognizes(PDA) Generates(CFG), TM: Recognizes(TM) Generates(Enumerator)"
    },

    {
        "instruction" : "Construction of an NFA N to recognize Union (regular languages closed under union)",
        "response" : "Let N1 = (Q1, Σ, δ1, q1, F1) and N2 = (Q2, Σ, δ2, q2, F2) be NFAs recognizing languages L1 and L2 respectively. We construct an NFA N = (Q, Σ, δ, q0, F) recognizing L1 ∪ L2 as follows: 1. Q = Q1 ∪ Q2 ∪ {q0}, where q0 is a new start state not in Q1 or Q2. 2. δ(q0, ε) = {q1, q2} (ε-transitions from the new start state to the start states of N1 and N2). 3. For all states q in Q1 and input symbols a in Σ, δ(q, a) = δ1(q, a). 4. For all states q in Q2 and input symbols a in Σ, δ(q, a) = δ2(q, a). 5. F = F1 ∪ F2 (the set of accept states is the union of the accept states of N1 and N2)."
    },

    {
        "instruction" : "Construction of N to recognize concatenation (regular languages closed under concatenation)",
        "response" : "Let N1 = (Q1, Σ, δ1, q1, F1) and N2 = (Q2, Σ, δ2, q2, F2) be NFAs recognizing languages L1 and L2 respectively. We construct an NFA N = (Q, Σ, δ, q1, F2) recognizing L1L2 as follows: 1. Q = Q1 ∪ Q2. 2. For all states q in Q1 and input symbols a in Σ, δ(q, a) = δ1(q, a). 3. For all states q in Q2 and input symbols a in Σ, δ(q, a) = δ2(q, a). 4. For each accept state f in F1, add an ε-transition from f to the start state q2 of N2: δ(f, ε) = {q2}. 5. The start state of N is the start state of N1 (q1), and the accept states of N are the accept states of N2 (F2)."
    },

    {
        "instruction" : "Construction of N to recognize Star (regular languages closed under star)",
        "response" : "Let N1 = (Q1, Σ, δ1, q1, F1) be an NFA recognizing language L1. We construct an NFA N = (Q, Σ, δ, q0, F) recognizing L1* as follows: 1. Q = Q1 ∪ {q0}, where q0 is a new start state not in Q1. 2. δ(q0, ε) = {q1} ∪ {q0} (ε-transition from the new start state to the start state of N1 and a self-loop on q0). 3. For all states q in Q1 and input symbols a in Σ, δ(q, a) = δ1(q, a). 4. For each accept state f in F1, add an ε-transition from f back to the start state q1 of N1: δ(f, ε) = {q1}. 5. The set of accept states F = F1 ∪ {q0} (the accept states include the accept states of N1 and the new start state q0)."
    },

    {
        "instruction" : "What makes a language polynomially verifiable?",
        "response" : "If it has a polytime verifier. The verifier uses a certificate that string w belongs to language A."
    },

    {
        "instruction" : "Describe HAMPATH certificate",
        "response" : "{w | V accepts <w, C>} and w = <G, s, t> and c is a path the visits each vertex exactly once from s to t."
    },

    {
        "instruction" : "What is the Class P",
        "response" : "class of languages or which mempership can be decided quickly (solvable)."
    },

    {
        "instruction" : "What is the Class NP",
        "response" : "Class of languages for which membership can be verified qucikly (Verified)"
    },

    {
        "instruction" : "Describe General PROOF FOR ALL NP PROBLEMS",
        "response" : "FORWARD PROOF: Have polytime verifier, V. Runs in time n^k. Build NDTM that runs in polytime. N = 'On input w of length n 1. ND select a string c of length at most n^k. 2. Run V on input <w, c> 3. If V acceptes accpet else reject.' BACKWARD PROOF: Have NDTM that is polytime N, Build poly time verifier. V = 'On input <w, c> w and c are strings 1. Run N on input w, using c to direct N on which ND choices to make. 2 If N accpets, accept; else reject.'"
    },

    {
        "instruction" : "What 2 conditions make a language NP-Complete?",
        "response" : "1. B ∈ NP 2. Every A ∈ NP is polynomial time reducible to B (∀(A ∈ NP) ≤p B)"
    },

    {
        "instruction" : "Show isomporhism is in NP",
        "response" : "A ND polynomial time alogrithim for ISA operates as follows: 'On input <G, H> where G and H are undirected graphs. 1. Let M be the number of nodes of G and H. If they don't have the samew number of nodes, REJCT. 2. Non-Deterministically(ND) select a permutation PI of elemnts. 3. For each pair of nodes x and y of G check that (x,y) is an edge of G iff (PI(x), PI(y)) is an edge of H. If all agree, ACCEPT, if any differ, REJECT.'"
    },

    {
        "instruction" : "Show that Triangle belongs to NP",
        "response" : "The following algorithim decides TRIANGLE ON input G: for each triplet of vetrices (u, v, w) in G. Return true if G contains all edges (u, v), (v, w), and (w, u) else Return False. Remark. By definition of TRIANGLE, the algorithm will return true iff G contains a triangle. Let n = |V| (num of vetices) and m = |E| (num of edges) in G. THere are O(n^3) many triplets of vertices in G and it is possible to enumerate in time O(n^3). For each Triplet, it takes time O(m) to verify presence of three edges so the alorithim runs in O(mn^3)."
    },

    {
        "instruction" : "Proving Something is a member of NP (using verifier method)",
        "response" : "If any problem is in NP, then given a certificate which is a solution to the problem and an instance of the problem, we will be able to verify the certificate in polynomial time."
    }
]